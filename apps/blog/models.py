# -*- coding: utf-8 -*-
"""
Blog post models
"""

from django.db import models
from django.conf import settings
from django.core.exceptions import ValidationError


class BlogPost(models.Model):
    """
    Blog post model
    """
    STATUS_CHOICES = [
        ('draft', 'Draft'),
        ('generating', 'AI Generating'),
        ('selecting', 'Selecting Article'),  # User is selecting from AI variations
        ('ready', 'Ready to Publish'),
        ('publishing', 'Publishing'),
        ('published', 'Published'),
        ('failed', 'Failed'),
    ]

    # Basic information
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='blog_posts',
        verbose_name='Author'
    )
    title = models.CharField(
        max_length=25,
        blank=True,
        default='',
        verbose_name='Title',
        help_text='Blog title (max 25 characters)'
    )
    content = models.TextField(
        blank=True,
        default='',
        verbose_name='Content',
        help_text='Final content with image placeholders'
    )
    generated_content = models.TextField(
        blank=True,
        verbose_name='Generated Content',
        help_text='AI-generated original content (backup)'
    )
    generated_variations = models.JSONField(
        default=list,
        blank=True,
        verbose_name='Generated Variations',
        help_text='AI-generated article variations for selection'
    )
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        default='draft',
        db_index=True,
        verbose_name='Status'
    )

    # AI generation related
    ai_prompt = models.TextField(
        blank=True,
        verbose_name='AI Prompt',
        help_text='Prompt sent to Gemini'
    )
    tone = models.CharField(
        max_length=50,
        blank=True,
        verbose_name='Tone',
        help_text='Tone and manner for content generation'
    )
    keywords = models.CharField(
        max_length=200,
        blank=True,
        verbose_name='Keywords',
        help_text='Keywords for content generation'
    )
    ai_generated = models.BooleanField(
        default=False,
        verbose_name='AI Generated',
        help_text='Whether this post was generated by AI'
    )

    # SALON BOARD posting parameters
    stylist_id = models.CharField(
        max_length=20,
        blank=True,
        verbose_name='Stylist ID',
        help_text='Stylist ID (T number, e.g., T000123456)'
    )
    coupon_name = models.CharField(
        max_length=100,
        blank=True,
        verbose_name='Coupon Name',
        help_text='Coupon name for partial match search'
    )

    # Task management
    celery_task_id = models.CharField(
        max_length=255,
        blank=True,
        db_index=True,
        verbose_name='Celery Task ID',
        help_text='Celery task ID for async processing'
    )

    # SALON BOARD posting result
    salon_board_url = models.URLField(
        blank=True,
        max_length=500,
        verbose_name='SALON BOARD URL',
        help_text='URL of the post on SALON BOARD'
    )
    published_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Published At',
        help_text='Datetime when post was published to SALON BOARD'
    )

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Created At')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Updated At')

    class Meta:
        verbose_name = 'Blog Post'
        verbose_name_plural = 'Blog Posts'
        db_table = 'blog_posts'
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['user', '-created_at']),
            models.Index(fields=['status']),
            models.Index(fields=['celery_task_id']),
            models.Index(fields=['-published_at']),
        ]

    def __str__(self):
        return f"{self.title} ({self.user.username})"

    def clean(self):
        """Validate model data"""
        # Title length validation
        if self.title and len(self.title) > 25:
            raise ValidationError({'title': 'Title must be 25 characters or less'})

        # Content is required for non-draft posts
        if self.status not in ['draft', 'generating', 'selecting'] and not self.content:
            raise ValidationError({'content': 'Content is required'})

    def get_image_count(self) -> int:
        """Get number of images attached to this post"""
        return self.images.count()

    def is_processable(self) -> bool:
        """Check if post can be processed for publishing"""
        return self.status in ['draft'] and self.images.exists()


class BlogImage(models.Model):
    """
    Blog image model
    """
    blog_post = models.ForeignKey(
        BlogPost,
        on_delete=models.CASCADE,
        related_name='images',
        verbose_name='Blog Post'
    )
    image_file = models.ImageField(
        upload_to='blog_images/%Y/%m/%d/',
        verbose_name='Image File'
    )
    order = models.PositiveSmallIntegerField(
        default=0,
        verbose_name='Order',
        help_text='Display order (0-based)'
    )
    uploaded_at = models.DateTimeField(
        auto_now_add=True,
        verbose_name='Uploaded At'
    )

    class Meta:
        verbose_name = 'Blog Image'
        verbose_name_plural = 'Blog Images'
        db_table = 'blog_images'
        ordering = ['blog_post', 'order']
        unique_together = [['blog_post', 'order']]
        indexes = [
            models.Index(fields=['blog_post', 'order']),
        ]

    def __str__(self):
        return f"Image {self.order + 1} for {self.blog_post.title}"

    @property
    def image_url(self) -> str:
        """Get image URL"""
        if self.image_file:
            return self.image_file.url
        return ""

    @property
    def file_path(self) -> str:
        """Get file path"""
        if self.image_file:
            return self.image_file.path
        return ""


class PostLog(models.Model):
    """
    Post execution log model
    """
    STATUS_CHOICES = [
        ('in_progress', 'In Progress'),
        ('success', 'Success'),
        ('failed', 'Failed'),
    ]

    # Relations
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='post_logs',
        verbose_name='User'
    )
    blog_post = models.OneToOneField(
        BlogPost,
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
        related_name='log',
        verbose_name='Blog Post'
    )

    # Status
    status = models.CharField(
        max_length=20,
        choices=STATUS_CHOICES,
        db_index=True,
        verbose_name='Status'
    )
    error_message = models.TextField(
        blank=True,
        verbose_name='Error Message'
    )

    # Record data
    screenshot_path = models.CharField(
        max_length=500,
        blank=True,
        verbose_name='Screenshot Path',
        help_text='Path to completion screenshot'
    )
    scraping_data = models.JSONField(
        default=dict,
        blank=True,
        verbose_name='Scraping Data',
        help_text='Data retrieved during scraping (JSON)'
    )
    duration_seconds = models.IntegerField(
        default=0,
        verbose_name='Duration (seconds)',
        help_text='Processing time in seconds'
    )

    # Timestamps
    started_at = models.DateTimeField(
        verbose_name='Started At'
    )
    completed_at = models.DateTimeField(
        null=True,
        blank=True,
        verbose_name='Completed At'
    )

    class Meta:
        verbose_name = 'Post Log'
        verbose_name_plural = 'Post Logs'
        db_table = 'post_logs'
        ordering = ['-started_at']
        indexes = [
            models.Index(fields=['user', '-started_at']),
            models.Index(fields=['status']),
            models.Index(fields=['-completed_at']),
        ]

    def __str__(self):
        return f"Log {self.id} - {self.status} ({self.user.username})"

    def calculate_duration(self):
        """Calculate and save processing duration"""
        if self.completed_at and self.started_at:
            delta = self.completed_at - self.started_at
            self.duration_seconds = int(delta.total_seconds())
            self.save(update_fields=['duration_seconds'])


class SALONBoardAccount(models.Model):
    """
    SALON BOARD account information (encrypted)
    """
    user = models.OneToOneField(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='salon_board_account',
        verbose_name='User'
    )
    login_id = models.CharField(
        max_length=255,
        blank=True,
        default='',
        verbose_name='Login ID',
        help_text='SALON BOARD login ID'
    )
    encrypted_password = models.TextField(
        verbose_name='Encrypted Password',
        help_text='Password encrypted with Fernet'
    )
    is_active = models.BooleanField(
        default=True,
        verbose_name='Active',
        help_text='Whether this account is active'
    )

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Created At')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Updated At')

    class Meta:
        verbose_name = 'SALON BOARD Account'
        verbose_name_plural = 'SALON BOARD Accounts'
        db_table = 'salon_board_accounts'

    def __str__(self):
        return f"{self.user.username} - {self.login_id}"

    def get_credentials(self) -> tuple:
        """
        Get decrypted credentials

        Returns:
            tuple: (login_id, password)
        """
        from cryptography.fernet import Fernet
        from django.conf import settings

        fernet = Fernet(settings.ENCRYPTION_KEY.encode())
        password = fernet.decrypt(self.encrypted_password.encode()).decode()
        return self.login_id, password

    def set_password(self, password: str):
        """
        Encrypt and set password

        Args:
            password: Plain text password
        """
        from cryptography.fernet import Fernet
        from django.conf import settings

        fernet = Fernet(settings.ENCRYPTION_KEY.encode())
        self.encrypted_password = fernet.encrypt(password.encode()).decode()


class BlogPostTemplate(models.Model):
    """
    User-defined blog post templates for footer text.

    Allows users to save common footer text (e.g., salon info, contact details)
    that can be quickly added to blog posts.
    """
    user = models.ForeignKey(
        settings.AUTH_USER_MODEL,
        on_delete=models.CASCADE,
        related_name='blog_post_templates',
        verbose_name='User'
    )
    name = models.CharField(
        max_length=100,
        verbose_name='Template Name',
        help_text='Short name to identify this template (e.g., "Standard Footer", "Campaign Info")'
    )
    content = models.TextField(
        max_length=500,
        verbose_name='Template Content',
        help_text='Footer text to append to blog posts (max 500 characters)'
    )

    # Timestamps
    created_at = models.DateTimeField(auto_now_add=True, verbose_name='Created At')
    updated_at = models.DateTimeField(auto_now=True, verbose_name='Updated At')

    class Meta:
        verbose_name = 'Blog Post Template'
        verbose_name_plural = 'Blog Post Templates'
        db_table = 'blog_post_templates'
        ordering = ['-created_at']
        constraints = [
            models.UniqueConstraint(
                fields=['user', 'name'],
                name='unique_template_name_per_user'
            )
        ]

    def __str__(self):
        return f"{self.user.username} - {self.name}"

    def clean(self):
        """Validate template content length."""
        from django.core.exceptions import ValidationError

        if len(self.content) > 500:
            raise ValidationError({
                'content': 'Template content must be 500 characters or less.'
            })
